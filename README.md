## 1. Аннотация и предметная область
Моделирование бизнес‑процессов является ключевым инструментом цифровой экономики: позволяет формализовать, анализировать и оптимизировать операции. Традиционная разработка диаграмм (BPMN, IDEF0, DFD и др.) требует значительных ресурсов и квалификации; автоматизированная генерация на основе текстовых описаний сокращает затраты и ускоряет работу. Интеллектуальные NLP‑системы извлекают сущности и связи из естественного языка и преобразуют их в наглядные схемы. Развитие подхода обеспечивается доступностью вычислительных мощностей, прогрессом в NLP и популяризацией ИИ. Преимущества включают быстрое выявление узких мест, автоматическое оформление документации и уменьшение ручного труда. Имеются вызовы: корректность интерпретации текста, адаптация к различным нотациям и вопросы стандартизации/регулирования. Направление соответствует приоритетам государственной цифровизации и инициативам по развитию ИИ.
## 2. Цели, границы и критерии готовности
**Цели:**
- Преобразование кратких текстовых сценариев бизнес‑процессов в машинно‑читаемую модель и её визуализацию.
- Предоставление простого веб‑интерфейса и REST API.
- Обеспечение воспроизводимой сборки и локального развёртывания через Docker Compose.

**Границы (MVP):**
- Поддержка основных конструкций процесса: **начала/окончания**, **действий (tasks)**, **лёгких условий (if/else)** и **последовательных переходов**.
- Диаграмма по умолчанию — **Mermaid flowchart**; экспорт **SVG**. Опционально — формирование **BPMN XML** (минимальный подмножество: StartEvent, Task, ExclusiveGateway, EndEvent, SequenceFlow).
- Русский и английский тексты; базовые эвристики + опциональный ML‑мод.

**Критерии готовности:**
- Сборка Maven, приложение Spring Boot запускается локально.
- Веб‑страница с полем ввода текста и предпросмотром диаграммы.
- REST‑эндпоинт `POST /api/v1/diagram/generate` возвращает артефакты (Mermaid, SVG, при включении — BPMN XML).
- Набор модульных тестов (JUnit) для ключевых преобразований.
- Docker Compose поднимает Java‑бэкенд (+ опциональный Python‑сервис для ML).
- Документация в README с примерами запросов/ответов и инструкциями.

## 3. Пользовательские интерфейсы
### 3.1. Веб‑интерфейс (UI)
- Текстовая область для ввода сценария.
- Выпадающие настройки: язык (RU/EN), тип диаграммы (flowchart/BPMN*), режим (rule/ML*), формат вывода (Mermaid/SVG/BPMN*).
- Предпросмотр: встраиваемый рендер **Mermaid**; для BPMN* — текстом (XML) и кнопка «Скачать».  
  \* — опциональная функция в рамках лабораторной работы.

### 3.2. REST API
- `POST /api/v1/diagram/generate` — генерация диаграммы.  
  **Request (JSON):**
  ```json
  {
    "text": "Описание процесса...",
    "diagram_type": "flowchart | bpmn",
    "mode": "rule | ml",
    "output": ["mermaid", "svg", "bpmn-xml"],
    "options": {
      "language": "auto | ru | en",
      "detect_swimlanes": false
    }
  }
  ```
  **Response (JSON):**
  ```json
  {
    "id": "dgrm-2025-0001",
    "artifacts": {
      "mermaid": "graph TD; A[Start]-->B[Task]; ...",
      "svg": "<svg>...</svg>",
      "bpmn_xml": "<definitions>...</definitions>"
    },
    "warnings": ["Найдены неоднозначные шаги: ..."],
    "stats": {"nodes": 7, "edges": 6, "mode": "rule"}
  }
  ```

- `GET /api/v1/diagram/{id}` — получение сохранённого результата (если включено локальное хранение файлов/кеша).

## 4. Взаимодействие с внешними системами
- **Рендеринг Mermaid** — локально в браузере (через встроенный скрипт) или серверная конверсия в SVG (через библиотеку/движок рендеринга).
- **Опциональная LLM/ML‑интеграция:** локальный Python‑сервис (FastAPI) с моделями HuggingFace для разметки сущностей и извлечения отношений. Внешние API (OpenAI/HF Inference) допускаются как экспериментальный режим при наличии ключа.
- **Импорт/экспорт BPMN:** работа с BPMN XML через библиотеку (например, `bpmn-moddle` на этапе экспорта в упрощённом виде) — опционально.

## 5. Архитектура: подсистемы, модули и пайплайн
### 5.1. Компоненты
- **UI (Thymeleaf/HTML + Mermaid)** — минималистичный одностраничный интерфейс.
- **API (Spring Boot, Java 17/21)** — REST‑слой и оркестрация пайплайна.
- **Parser** — нормализация текста, сегментация на шаги, извлечение сущностей/отношений.
- **Graph Builder** — построение ориентированного графа процесса (узлы/рёбра).
- **Render/Export** — генерация Mermaid и SVG; опционально — BPMN XML.
- **ML Adapter (опционально)** — клиент к Python‑сервису или внешнему API.
- **Storage (опционально)** — локальный файловый кеш результатов.

### 5.2. Пайплайн обработки
1. **Preprocessing:** детекция языка (при `auto`), очистка, разбиение на предложения/шаги.
2. **Extraction:** эвристики (по ключевым словам и шаблонам) либо ML‑мод (NER для ACTIVITY/CONDITION/ROLE/EVENT и классификатор отношений SEQ/BRANCH).
3. **Normalization:** нормализация лемм, унификация имён узлов, дедупликация.
4. **Graph Building:** создание узлов (**Start**, **Task**, **Gateway(if/else)**, **End**) и рёбер; генерация уникальных идентификаторов.
5. **Layout/Serialize:** представление графа в **Mermaid**; опционально — экспорт в **BPMN XML** (минимальный поднабор элементов).
6. **Render:** клиентский рендер Mermaid и/или серверная выдача **SVG**.
7. **Persist (опционально):** запись артефактов в `./data/diagrams`.

### 5.3. Форматы данных (внутренний граф)
```json
{
  "nodes": [
    {"id":"n1","type":"start","label":"Start"},
    {"id":"n2","type":"task","label":"Принять заявку"},
    {"id":"n3","type":"gateway","label":"Проверка данных"},
    {"id":"n4","type":"task","label":"Уточнить информацию"},
    {"id":"n5","type":"end","label":"End"}
  ],
  "edges":[
    {"from":"n1","to":"n2","type":"seq"},
    {"from":"n2","to":"n3","type":"seq"},
    {"from":"n3","to":"n4","type":"branch","cond":"если неполные данные"},
    {"from":"n3","to":"n5","type":"branch","cond":"иначе"}
  ]
}
```

## 6. Используемые модели и алгоритмы ИИ/МО
### 6.1. Базовый режим (rule)
- Шаблоны по ключевым словам: «начало/старт», «завершить/конец», глаголы действия → **Task**, маркеры условий «если/иначе/в противном случае» → **Exclusive Gateway**.
- Регулярные выражения для нумерованных/маркированных шагов.
- Простая эвристика для ветвлений: после «если» — ветка 1, после «иначе» — ветка 2.

### 6.2. ML‑режим (опционально)
- **NER** для извлечения ACTIVITY, CONDITION, ROLE, EVENT (например, `flan-t5-small`/`distilbert`‑базовые пайплайны через HuggingFace).
- **Классификация отношений** между предложениями: SEQ, BRANCH (Бинарная/многоклассовая логистика/трансформер).
- Интеграция через мини‑сервис **Python + FastAPI**, вызываемый из Java (REST).

## 7. Методы обучения и требования к данным
- Набор из 50–100 кратких сценариев (2–10 шагов) на RU/EN; разрешается синтетическая генерация по шаблонам.
- Разметка для NER в формате spaCy/CoNLL; отдельные связи «A → B», тип связи (SEQ/BRANCH) и пометки условий.
- Баланс и разнообразие: наличие простых линейных сценариев и сценариев с 1–2 ветвлениями.
- Объём лабораторного обучения минимальный; допускается использовать предобученные модели без дообучения как baseline.

## 8. Валидация и тестирование
- **Unit‑тесты (JUnit):** парсер шагов, извлечение условий, построение графа.
- **Integration‑тесты:** запрос `POST /generate` → корректный Mermaid/SVG и статистика.
- **Quality‑метрики для графа:** точность/полнота по множествам узлов и рёбер (сравнение с эталоном JSON).
- **Snapshot‑тесты SVG:** сравнение нормализованного SVG (без нестабильных атрибутов).
- **Набор эталонов (`/testdata/golden/`)** — минимум 10 кейсов RU/EN.

## 9. Варианты развёртывания
1. **Локальный запуск (разработчик):** `mvn spring-boot:run`.
2. **Docker Compose:**
    - Сервис `app` (Java) — API/UI.
    - Сервис `nlp` (Python, опционально) — NER/relations.  
      Пример `docker-compose.yml` входит в репозиторий.
3. **Single JAR:** `java -jar bptext2diagram.jar` — без ML‑модуля.

## 10. Подготовка к развёртыванию
- Установить JDK 17+ (или 21), Maven 3.9+.
- (Опционально) Python 3.11+, virtualenv, зависимости `requirements.txt` для `nlp`‑сервиса.
- При использовании внешних LLM — задать ключи в `.env` (`OPENAI_API_KEY` и т.п.).
- Прогнать тесты: `mvn test`.
- Проверить формирование Mermaid и SVG на примере из раздела 14.

## 11. Нефункциональные требования
- Производительность: обработка сценария до 10 шагов ≤ 2 с (rule‑режим) на типовом ноутбуке.
- Удобство: работа без сложной настройки; все зависимости контейнеризованы.
- Качество: не менее 80% совпадения узлов/рёбер на эталонном наборе (rule‑режим).

## 12. Ограничения и риски
- Естественный язык неоднозначен; без обогащённых подсказок возможны упрощения графа.
- Отсутствие сложных BPMN‑конструкций (пулы/события/типы задач) в MVP.
- ML‑модуль зависит от доступности/настройки Python‑окружения или внешних API.


## 13. Пример использования
**Входной текст:**
```
Начало процесса. Принять заявку. Если данные неполные, уточнить информацию, иначе перейти к обработке. Завершить процесс.
```
**Mermaid (ожидаемый фрагмент):**
```
graph TD
  S([Start]) --> T1[Принять заявку]
  T1 --> G1{Проверка данных}
  G1 -->|если неполные| T2[Уточнить информацию]
  G1 -->|иначе| T3[Обработка]
  T2 --> T3
  T3 --> E([End])
```

## 14. Структура репозитория
```
diagram-ai/
├─ app/                      # Java Spring Boot приложение
│  ├─ src/main/java/...      # контроллеры, сервисы, парсер, билдер
│  ├─ src/main/resources/    # шаблоны Thymeleaf, статические ресурсы
│  ├─ pom.xml
├─ nlp/ (optional)           # Python FastAPI + модели
│  ├─ main.py
│  ├─ requirements.txt
├─ data/
│  ├─ diagrams/              # сохраняемые артефакты (SVG/BPMN)
│  └─ testdata/golden/       # эталонные кейсы
├─ docker-compose.yml
├─ README.md                 # текущее ТЗ и инструкции
└─ LICENSE
```

## 15. Roadmap после MVP (по желанию)
- Выделение ролей/свимлейнов (swimlanes) и генерация **Mermaid with subgraphs**.
- Улучшение экспорта **BPMN 2.0** (расширение набора элементов).
- Импорт BPMN XML → авто‑генерация текстового описания (обратное преобразование).
- Автоматическое составление **CJM/EPIC→PROCESS** черновиков для доменных задач.

---

### Инструкции по запуску (кратко)
```bash
# 1) Локально (без ML):
mvn -q -f app/pom.xml spring-boot:run

# 2) Docker Compose (Java + опционально Python):
docker compose up --build
```

### Примечание
При отсутствии имени пользователя GitHub в ссылке используется шаблон. Для публикации необходимо создать пустой репозиторий `bptext2diagram` и поместить этот README.md в корень.
